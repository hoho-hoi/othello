diff --git a/.cursor/commands/engineer-task.md b/.cursor/commands/engineer-task.md
index aa9845a..13e57b9 100644
--- a/.cursor/commands/engineer-task.md
+++ b/.cursor/commands/engineer-task.md
@@ -65,7 +65,7 @@
      - どの Acceptance Criteria を、どのテストとどの実装で満たしたかの対応表
        - 例:
          - AC1 → `tests/xxx.test.ts` の `<test name>` → `src/yyy.ts` の `<function>`
-4. `gh-engineer pr create` を実行し、上記の本文を指定して PR を作成する（`--body` または `--body-file` を使用）。
+4. `gh-engineer pr create` を実行し、上記の本文を指定して PR を作成する（`--body` または `--body-file` を使用）(`gh` ではなく `gh-engineer` を使用することに注意)。
 
 5. PR を作成したら、ユーザーに「PR 番号」と「次に Manager を呼び出すためのプロンプト」を含むアクションブロックを表示する（例）:
 
diff --git a/src/App.test.tsx b/src/App.test.tsx
index 11a9868..e35c277 100644
--- a/src/App.test.tsx
+++ b/src/App.test.tsx
@@ -1,17 +1,60 @@
-import { describe, it, expect } from 'vitest'
-import { render, screen } from '@testing-library/react'
+import { describe, it, expect, vi, beforeEach } from 'vitest'
+import { render, screen, waitFor } from '@testing-library/react'
 import App from './App'
+import * as gameState from './app/gameState'
+import { createInitialBoard } from './domain/rules'
+
+vi.mock('./app/gameState')
 
 describe('App', () => {
-  it('renders the app title', () => {
+  beforeEach(() => {
+    vi.clearAllMocks()
+  })
+
+  it('should show loading state initially', () => {
+    vi.mocked(gameState.initializeGame).mockResolvedValue({
+      success: true,
+      gameState: {
+        board: createInitialBoard(),
+        nextTurnColor: 'BLACK',
+        isFinished: false,
+      },
+      moves: [],
+    })
+
     render(<App />)
-    expect(screen.getByText('Othello')).toBeInTheDocument()
+    expect(screen.getByText(/loading/i)).toBeInTheDocument()
   })
 
-  it('renders setup complete message', () => {
+  it('should transition to playing state after successful initialization', async () => {
+    vi.mocked(gameState.initializeGame).mockResolvedValue({
+      success: true,
+      gameState: {
+        board: createInitialBoard(),
+        nextTurnColor: 'BLACK',
+        isFinished: false,
+      },
+      moves: [],
+    })
+
     render(<App />)
-    expect(
-      screen.getByText('Setup complete. Ready for development.')
-    ).toBeInTheDocument()
+
+    await waitFor(() => {
+      expect(screen.queryByText(/loading/i)).not.toBeInTheDocument()
+    })
+  })
+
+  it('should transition to error state on initialization failure', async () => {
+    vi.mocked(gameState.initializeGame).mockResolvedValue({
+      success: false,
+      error: 'Storage read error',
+    })
+
+    render(<App />)
+
+    await waitFor(() => {
+      expect(screen.getByText('Error')).toBeInTheDocument()
+      expect(screen.getByText('Storage read error')).toBeInTheDocument()
+    })
   })
 })
diff --git a/src/App.tsx b/src/App.tsx
index 959c3e4..7d53da5 100644
--- a/src/App.tsx
+++ b/src/App.tsx
@@ -1,10 +1,106 @@
+/**
+ * Main App Component
+ *
+ * Handles OP_OPEN_APP: App launch with automatic game restoration or new game creation.
+ * R1: STATE_LOADINGで起動時に「復元 or 新規生成」が行われる
+ * R3: Save/Load失敗時はクラッシュせず、STATE_ERRORへ遷移できる
+ */
+
+import { useEffect, useState } from 'react'
+import { initializeGame, type AppState } from './app/gameState'
+
 function App() {
-  return (
-    <div>
-      <h1>Othello</h1>
-      <p>Setup complete. Ready for development.</p>
-    </div>
-  )
+  const [appState, setAppState] = useState<AppState>({ type: 'LOADING' })
+
+  useEffect(() => {
+    // R1: Initialize game on app launch
+    const loadGame = async () => {
+      const result = await initializeGame()
+
+      if (result.success) {
+        // Transition to PLAYING state
+        setAppState({
+          type: 'PLAYING',
+          gameState: result.gameState,
+          moves: result.moves,
+        })
+      } else {
+        // R3: Transition to ERROR state on failure (no crash)
+        setAppState({
+          type: 'ERROR',
+          error: result.error,
+        })
+      }
+    }
+
+    loadGame()
+  }, [])
+
+  // Render based on current state
+  if (appState.type === 'LOADING') {
+    return (
+      <div>
+        <h1>Othello</h1>
+        <p>Loading...</p>
+      </div>
+    )
+  }
+
+  if (appState.type === 'ERROR') {
+    return (
+      <div>
+        <h1>Othello</h1>
+        <div>
+          <h2>Error</h2>
+          <p>{appState.error}</p>
+          <button
+            onClick={() => {
+              // Retry initialization
+              setAppState({ type: 'LOADING' })
+              initializeGame().then((result) => {
+                if (result.success) {
+                  setAppState({
+                    type: 'PLAYING',
+                    gameState: result.gameState,
+                    moves: result.moves,
+                  })
+                } else {
+                  setAppState({
+                    type: 'ERROR',
+                    error: result.error,
+                  })
+                }
+              })
+            }}
+          >
+            Retry
+          </button>
+        </div>
+      </div>
+    )
+  }
+
+  if (appState.type === 'PLAYING') {
+    return (
+      <div>
+        <h1>Othello</h1>
+        <p>Game loaded. Ready to play.</p>
+        <p>Next turn: {appState.gameState.nextTurnColor}</p>
+        <p>Moves: {appState.moves.length}</p>
+      </div>
+    )
+  }
+
+  if (appState.type === 'RESULT') {
+    return (
+      <div>
+        <h1>Othello</h1>
+        <p>Game finished.</p>
+      </div>
+    )
+  }
+
+  return null
 }
 
 export default App
diff --git a/src/app/gameState.test.ts b/src/app/gameState.test.ts
new file mode 100644
index 0000000..109d3e8
--- /dev/null
+++ b/src/app/gameState.test.ts
@@ -0,0 +1,99 @@
+/**
+ * Tests for game state management and initialization
+ */
+
+import { describe, it, expect, beforeEach, vi } from 'vitest'
+import { initializeGame } from './gameState'
+import { createInitialBoard } from '../domain/rules'
+import * as deviceLocalStorage from '../storage/deviceLocalStorage'
+
+vi.mock('../storage/deviceLocalStorage')
+
+describe('initializeGame', () => {
+  beforeEach(() => {
+    vi.clearAllMocks()
+  })
+
+  it('should create new game when no saved game exists', async () => {
+    vi.mocked(deviceLocalStorage.loadGameFromDeviceLocal).mockReturnValue({
+      success: true,
+      record: null,
+    })
+
+    const result = await initializeGame()
+
+    expect(result.success).toBe(true)
+    if (result.success) {
+      expect(result.gameState).toBeTruthy()
+      expect(result.gameState.board).toEqual(createInitialBoard())
+      expect(result.gameState.nextTurnColor).toBe('BLACK')
+      expect(result.gameState.isFinished).toBe(false)
+      expect(result.moves).toEqual([])
+    }
+  })
+
+  it('should restore game from saved moves', async () => {
+    const savedMoves = [
+      {
+        moveNumber: 1,
+        color: 'BLACK' as const,
+        row: 2 as const,
+        col: 3 as const,
+        isPass: false,
+      },
+      {
+        moveNumber: 2,
+        color: 'WHITE' as const,
+        row: 4 as const,
+        col: 5 as const,
+        isPass: false,
+      },
+    ]
+
+    vi.mocked(deviceLocalStorage.loadGameFromDeviceLocal).mockReturnValue({
+      success: true,
+      record: {
+        formatVersion: 1,
+        moves: savedMoves,
+      },
+    })
+
+    const result = await initializeGame()
+
+    expect(result.success).toBe(true)
+    if (result.success) {
+      expect(result.gameState).toBeTruthy()
+      expect(result.moves).toEqual(savedMoves)
+      // Board should be recomputed from moves
+      expect(result.gameState.board).toBeTruthy()
+    }
+  })
+
+  it('should handle storage load errors', async () => {
+    vi.mocked(deviceLocalStorage.loadGameFromDeviceLocal).mockReturnValue({
+      success: false,
+      error: 'Storage read error',
+    })
+
+    const result = await initializeGame()
+
+    expect(result.success).toBe(false)
+    if (!result.success) {
+      expect(result.error).toContain('Storage')
+    }
+  })
+
+  it('should handle invalid record format errors', async () => {
+    vi.mocked(deviceLocalStorage.loadGameFromDeviceLocal).mockReturnValue({
+      success: false,
+      error: 'Invalid record format: formatVersion must be 1',
+    })
+
+    const result = await initializeGame()
+
+    expect(result.success).toBe(false)
+    if (!result.success) {
+      expect(result.error).toContain('format')
+    }
+  })
+})
diff --git a/src/app/gameState.ts b/src/app/gameState.ts
new file mode 100644
index 0000000..cfd907b
--- /dev/null
+++ b/src/app/gameState.ts
@@ -0,0 +1,105 @@
+/**
+ * Game State Management
+ *
+ * Handles game initialization, state transitions, and persistence.
+ */
+
+import { loadGameFromDeviceLocal } from '../storage/deviceLocalStorage'
+import {
+  createInitialBoard,
+  recomputeBoardFromMoves,
+  isGameFinished,
+} from '../domain/rules'
+import type { GameState, Move, PieceColor } from '../domain/types'
+
+/**
+ * Application state
+ */
+export type AppState =
+  | { readonly type: 'LOADING' }
+  | {
+      readonly type: 'PLAYING'
+      readonly gameState: GameState
+      readonly moves: readonly Move[]
+    }
+  | { readonly type: 'ERROR'; readonly error: string }
+  | {
+      readonly type: 'RESULT'
+      readonly gameState: GameState
+      readonly moves: readonly Move[]
+    }
+
+/**
+ * Game initialization result
+ */
+export type GameInitializationResult =
+  | {
+      readonly success: true
+      readonly gameState: GameState
+      readonly moves: readonly Move[]
+    }
+  | { readonly success: false; readonly error: string }
+
+/**
+ * Initialize game from DeviceLocal storage or create new game
+ *
+ * R1: STATE_LOADINGの意図どおり、起動時に「復元 or 新規生成」が行われる
+ */
+export async function initializeGame(): Promise<GameInitializationResult> {
+  // Load from DeviceLocal storage
+  const loadResult = loadGameFromDeviceLocal()
+
+  if (!loadResult.success) {
+    return {
+      success: false,
+      error: `Failed to load game: ${loadResult.error}`,
+    }
+  }
+
+  // If no saved game exists, create new game
+  if (loadResult.record === null) {
+    const initialBoard = createInitialBoard()
+    const gameState: GameState = {
+      board: initialBoard,
+      nextTurnColor: 'BLACK',
+      isFinished: false,
+    }
+    return {
+      success: true,
+      gameState,
+      moves: [],
+    }
+  }
+
+  // Restore game from saved moves
+  const moves = loadResult.record.moves
+
+  // Recompute board state from moves (R2: movesを真実源にし、派生情報は再計算)
+  const board = recomputeBoardFromMoves(moves)
+
+  // Determine next turn color
+  // After applying all moves, next turn should be opposite of last move color
+  let nextTurnColor: PieceColor = 'BLACK'
+  if (moves.length > 0) {
+    const lastMove = moves[moves.length - 1]
+    nextTurnColor = lastMove.color === 'BLACK' ? 'WHITE' : 'BLACK'
+  }
+
+  // Check if game is finished
+  // We need previous turn color to check finish condition
+  const previousTurnColor: PieceColor =
+    moves.length > 0 ? moves[moves.length - 1].color : 'WHITE' // If no moves, previous was WHITE (before BLACK starts)
+  const isFinished = isGameFinished(board, nextTurnColor, previousTurnColor)
+
+  const gameState: GameState = {
+    board,
+    nextTurnColor,
+    isFinished,
+  }
+
+  return {
+    success: true,
+    gameState,
+    moves,
+  }
+}
diff --git a/src/domain/rules.ts b/src/domain/rules.ts
index 262ab99..79102b2 100644
--- a/src/domain/rules.ts
+++ b/src/domain/rules.ts
@@ -273,7 +273,7 @@ export function computeGameResult(board: Board): GameResult {
  * Recompute board state from moves sequence
  * Starts from initial board and applies moves in order
  */
-export function recomputeBoardFromMoves(moves: Move[]): Board {
+export function recomputeBoardFromMoves(moves: readonly Move[]): Board {
   let board = createInitialBoard()
   let currentTurnColor: PieceColor = 'BLACK'
 
diff --git a/src/storage/deviceLocalStorage.test.ts b/src/storage/deviceLocalStorage.test.ts
new file mode 100644
index 0000000..ed365f6
--- /dev/null
+++ b/src/storage/deviceLocalStorage.test.ts
@@ -0,0 +1,211 @@
+/**
+ * Tests for DeviceLocal storage adapter
+ */
+
+import { describe, it, expect, beforeEach } from 'vitest'
+import {
+  loadGameFromDeviceLocal,
+  saveGameToDeviceLocal,
+  clearGameFromDeviceLocal,
+} from './deviceLocalStorage'
+import type { Move } from '../domain/types'
+
+// Mock localStorage with actual store behavior
+const createLocalStorageMock = () => {
+  let store: Record<string, string> = {}
+  return {
+    getItem: (key: string) => store[key] || null,
+    setItem: (key: string, value: string) => {
+      store[key] = value
+    },
+    removeItem: (key: string) => {
+      delete store[key]
+    },
+    clear: () => {
+      store = {}
+    },
+  }
+}
+
+const localStorageMock = createLocalStorageMock()
+
+Object.defineProperty(window, 'localStorage', {
+  value: localStorageMock,
+  writable: true,
+})
+
+describe('DeviceLocal Storage', () => {
+  beforeEach(() => {
+    localStorageMock.clear()
+  })
+
+  describe('saveGameToDeviceLocal', () => {
+    it('should save empty game record', () => {
+      const moves: Move[] = []
+      const result = saveGameToDeviceLocal(moves)
+      expect(result.success).toBe(true)
+      const savedValue = localStorageMock.getItem('othello_current_game')
+      expect(savedValue).toBeTruthy()
+      const parsed = JSON.parse(savedValue!)
+      expect(parsed.formatVersion).toBe(1)
+      expect(parsed.moves).toHaveLength(0)
+    })
+
+    it('should save game record with moves', () => {
+      const moves: Move[] = [
+        {
+          moveNumber: 1,
+          color: 'BLACK',
+          row: 2,
+          col: 3,
+          isPass: false,
+        },
+        {
+          moveNumber: 2,
+          color: 'WHITE',
+          row: 4,
+          col: 5,
+          isPass: false,
+        },
+      ]
+      const result = saveGameToDeviceLocal(moves)
+      expect(result.success).toBe(true)
+      const savedValue = localStorageMock.getItem('othello_current_game')
+      const parsed = JSON.parse(savedValue!)
+      expect(parsed.formatVersion).toBe(1)
+      expect(parsed.moves).toHaveLength(2)
+    })
+
+    it('should handle storage quota exceeded error', () => {
+      const originalSetItem = localStorageMock.setItem
+      localStorageMock.setItem = () => {
+        const error = new Error('QuotaExceededError')
+        error.name = 'QuotaExceededError'
+        throw error
+      }
+      const moves: Move[] = []
+      const result = saveGameToDeviceLocal(moves)
+      expect(result.success).toBe(false)
+      if (!result.success) {
+        expect(result.error).toContain('quota')
+      }
+      localStorageMock.setItem = originalSetItem
+    })
+
+    it('should handle other storage errors', () => {
+      const originalSetItem = localStorageMock.setItem
+      localStorageMock.setItem = () => {
+        throw new Error('Storage error')
+      }
+      const moves: Move[] = []
+      const result = saveGameToDeviceLocal(moves)
+      expect(result.success).toBe(false)
+      if (!result.success) {
+        expect(result.error).toBeTruthy()
+      }
+      localStorageMock.setItem = originalSetItem
+    })
+  })
+
+  describe('loadGameFromDeviceLocal', () => {
+    it('should return null when no saved game exists', () => {
+      const result = loadGameFromDeviceLocal()
+      expect(result.success).toBe(true)
+      if (result.success) {
+        expect(result.record).toBeNull()
+      }
+    })
+
+    it('should load valid game record', () => {
+      const record = {
+        formatVersion: 1,
+        moves: [
+          {
+            moveNumber: 1,
+            color: 'BLACK',
+            row: 2,
+            col: 3,
+            isPass: false,
+          },
+        ],
+      }
+      localStorageMock.setItem('othello_current_game', JSON.stringify(record))
+      const result = loadGameFromDeviceLocal()
+      expect(result.success).toBe(true)
+      if (result.success) {
+        expect(result.record).toBeTruthy()
+        expect(result.record?.moves).toHaveLength(1)
+      }
+    })
+
+    it('should reject invalid JSON', () => {
+      localStorageMock.setItem('othello_current_game', 'invalid json')
+      const result = loadGameFromDeviceLocal()
+      expect(result.success).toBe(false)
+      if (!result.success) {
+        expect(result.error).toContain('JSON')
+      }
+    })
+
+    it('should reject invalid record format', () => {
+      const invalidRecord = {
+        formatVersion: 2,
+        moves: [],
+      }
+      localStorageMock.setItem(
+        'othello_current_game',
+        JSON.stringify(invalidRecord)
+      )
+      const result = loadGameFromDeviceLocal()
+      expect(result.success).toBe(false)
+      if (!result.success) {
+        expect(result.error).toContain('formatVersion')
+      }
+    })
+
+    it('should handle storage read errors', () => {
+      const originalGetItem = localStorageMock.getItem
+      localStorageMock.getItem = () => {
+        throw new Error('Storage read error')
+      }
+      const result = loadGameFromDeviceLocal()
+      expect(result.success).toBe(false)
+      if (!result.success) {
+        expect(result.error).toBeTruthy()
+      }
+      localStorageMock.getItem = originalGetItem
+    })
+  })
+
+  describe('clearGameFromDeviceLocal', () => {
+    it('should remove saved game', () => {
+      const moves: Move[] = [
+        {
+          moveNumber: 1,
+          color: 'BLACK',
+          row: 2,
+          col: 3,
+          isPass: false,
+        },
+      ]
+      const saveResult = saveGameToDeviceLocal(moves)
+      expect(saveResult.success).toBe(true)
+
+      // Verify game was saved
+      const loadBeforeClear = loadGameFromDeviceLocal()
+      expect(loadBeforeClear.success).toBe(true)
+      if (loadBeforeClear.success) {
+        expect(loadBeforeClear.record).toBeTruthy()
+      }
+
+      clearGameFromDeviceLocal()
+
+      // After clear, should return null
+      const loadResult = loadGameFromDeviceLocal()
+      expect(loadResult.success).toBe(true)
+      if (loadResult.success) {
+        expect(loadResult.record).toBeNull()
+      }
+    })
+  })
+})
diff --git a/src/storage/deviceLocalStorage.ts b/src/storage/deviceLocalStorage.ts
new file mode 100644
index 0000000..e2ce471
--- /dev/null
+++ b/src/storage/deviceLocalStorage.ts
@@ -0,0 +1,130 @@
+/**
+ * DeviceLocal Storage Adapter
+ *
+ * Uses browser localStorage for persistence.
+ * Choice: localStorage over IndexedDB because:
+ * - Simpler API for single key-value storage
+ * - Sufficient for moves-only record format (typically < 10KB)
+ * - Better browser support and synchronous API
+ * - No need for complex queries or transactions
+ */
+
+import type { Move } from '../domain/types'
+import {
+  parseRecordFormat,
+  serializeRecordFormat,
+  type RecordFormat,
+  validateRecordFormat,
+} from './recordFormat'
+
+const STORAGE_KEY = 'othello_current_game'
+
+/**
+ * Storage operation result
+ */
+export type StorageResult<T> =
+  | { readonly success: true; readonly data: T }
+  | { readonly success: false; readonly error: string }
+
+/**
+ * Save game moves to DeviceLocal storage
+ *
+ * Uses Record Format (moves-only / formatVersion=1).
+ * Handles storage quota errors gracefully.
+ */
+export function saveGameToDeviceLocal(
+  moves: readonly Move[]
+): StorageResult<void> {
+  try {
+    const record: RecordFormat = {
+      formatVersion: 1,
+      moves,
+    }
+
+    // Validate before saving
+    const validation = validateRecordFormat(record)
+    if (!validation.success) {
+      return {
+        success: false,
+        error: `Validation failed before save: ${validation.error}`,
+      }
+    }
+
+    const json = serializeRecordFormat(record)
+
+    // Check size limit (1 MiB as per REQUIREMENT.md)
+    const MAX_SIZE = 1024 * 1024
+    if (json.length > MAX_SIZE) {
+      return {
+        success: false,
+        error: `Record size exceeds limit: ${json.length} bytes > ${MAX_SIZE} bytes`,
+      }
+    }
+
+    localStorage.setItem(STORAGE_KEY, json)
+
+    return { success: true, data: undefined }
+  } catch (error) {
+    if (
+      error instanceof Error &&
+      (error.name === 'QuotaExceededError' ||
+        error.message.includes('QuotaExceededError'))
+    ) {
+      return {
+        success: false,
+        error:
+          'Storage quota exceeded. Please free up space or export your game.',
+      }
+    }
+    return {
+      success: false,
+      error: `Storage save error: ${error instanceof Error ? error.message : String(error)}`,
+    }
+  }
+}
+
+/**
+ * Load game moves from DeviceLocal storage
+ *
+ * Returns null if no saved game exists.
+ * Validates record format before returning.
+ */
+export type LoadGameResult =
+  | { readonly success: true; readonly record: RecordFormat | null }
+  | { readonly success: false; readonly error: string }
+
+export function loadGameFromDeviceLocal(): LoadGameResult {
+  try {
+    const json = localStorage.getItem(STORAGE_KEY)
+    if (json === null) {
+      return { success: true, record: null }
+    }
+
+    const parseResult = parseRecordFormat(json)
+    if (!parseResult.success) {
+      return {
+        success: false,
+        error: `Invalid record format: ${parseResult.error}`,
+      }
+    }
+
+    return { success: true, record: parseResult.record! }
+  } catch (error) {
+    return {
+      success: false,
+      error: `Storage load error: ${error instanceof Error ? error.message : String(error)}`,
+    }
+  }
+}
+
+/**
+ * Clear saved game from DeviceLocal storage
+ */
+export function clearGameFromDeviceLocal(): void {
+  try {
+    localStorage.removeItem(STORAGE_KEY)
+  } catch (error) {
+    // Silently ignore clear errors (non-critical)
+    console.warn('Failed to clear storage:', error)
+  }
+}
diff --git a/src/storage/recordFormat.test.ts b/src/storage/recordFormat.test.ts
new file mode 100644
index 0000000..5ef7154
--- /dev/null
+++ b/src/storage/recordFormat.test.ts
@@ -0,0 +1,259 @@
+/**
+ * Tests for Record Format validation and serialization
+ */
+
+import { describe, it, expect } from 'vitest'
+import {
+  validateRecordFormat,
+  serializeRecordFormat,
+  type RecordFormat,
+} from './recordFormat'
+
+describe('validateRecordFormat', () => {
+  it('should accept valid record format with empty moves', () => {
+    const record: RecordFormat = {
+      formatVersion: 1,
+      moves: [],
+    }
+    const result = validateRecordFormat(record)
+    expect(result.success).toBe(true)
+  })
+
+  it('should accept valid record format with moves', () => {
+    const record: RecordFormat = {
+      formatVersion: 1,
+      moves: [
+        {
+          moveNumber: 1,
+          color: 'BLACK',
+          row: 2,
+          col: 3,
+          isPass: false,
+        },
+        {
+          moveNumber: 2,
+          color: 'WHITE',
+          row: 4,
+          col: 5,
+          isPass: false,
+        },
+      ],
+    }
+    const result = validateRecordFormat(record)
+    expect(result.success).toBe(true)
+  })
+
+  it('should accept valid record format with pass moves', () => {
+    const record: RecordFormat = {
+      formatVersion: 1,
+      moves: [
+        {
+          moveNumber: 1,
+          color: 'BLACK',
+          row: 2,
+          col: 3,
+          isPass: false,
+        },
+        {
+          moveNumber: 2,
+          color: 'WHITE',
+          row: null,
+          col: null,
+          isPass: true,
+        },
+      ],
+    }
+    const result = validateRecordFormat(record)
+    expect(result.success).toBe(true)
+  })
+
+  it('should reject missing formatVersion', () => {
+    const record = {
+      moves: [],
+    } as unknown as RecordFormat
+    const result = validateRecordFormat(record)
+    expect(result.success).toBe(false)
+    if (!result.success) {
+      expect(result.error).toContain('formatVersion')
+    }
+  })
+
+  it('should reject invalid formatVersion', () => {
+    const record = {
+      formatVersion: 2,
+      moves: [],
+    } as unknown as RecordFormat
+    const result = validateRecordFormat(record)
+    expect(result.success).toBe(false)
+    if (!result.success) {
+      expect(result.error).toContain('formatVersion')
+    }
+  })
+
+  it('should reject missing moves', () => {
+    const record = {
+      formatVersion: 1,
+    } as unknown as RecordFormat
+    const result = validateRecordFormat(record)
+    expect(result.success).toBe(false)
+    if (!result.success) {
+      expect(result.error).toContain('moves')
+    }
+  })
+
+  it('should reject moves not sorted by moveNumber', () => {
+    const record: RecordFormat = {
+      formatVersion: 1,
+      moves: [
+        {
+          moveNumber: 2,
+          color: 'WHITE',
+          row: 4,
+          col: 5,
+          isPass: false,
+        },
+        {
+          moveNumber: 1,
+          color: 'BLACK',
+          row: 2,
+          col: 3,
+          isPass: false,
+        },
+      ],
+    }
+    const result = validateRecordFormat(record)
+    expect(result.success).toBe(false)
+    if (!result.success) {
+      expect(result.error).toContain('moveNumber')
+    }
+  })
+
+  it('should reject moves with gaps in moveNumber', () => {
+    const record: RecordFormat = {
+      formatVersion: 1,
+      moves: [
+        {
+          moveNumber: 1,
+          color: 'BLACK',
+          row: 2,
+          col: 3,
+          isPass: false,
+        },
+        {
+          moveNumber: 3,
+          color: 'WHITE',
+          row: 4,
+          col: 5,
+          isPass: false,
+        },
+      ],
+    }
+    const result = validateRecordFormat(record)
+    expect(result.success).toBe(false)
+    if (!result.success) {
+      expect(result.error).toContain('moveNumber')
+    }
+  })
+
+  it('should reject invalid color', () => {
+    const record = {
+      formatVersion: 1,
+      moves: [
+        {
+          moveNumber: 1,
+          color: 'RED',
+          row: 2,
+          col: 3,
+          isPass: false,
+        },
+      ],
+    } as unknown as RecordFormat
+    const result = validateRecordFormat(record)
+    expect(result.success).toBe(false)
+    if (!result.success) {
+      expect(result.error).toContain('color')
+    }
+  })
+
+  it('should reject non-pass move with null row/col', () => {
+    const record: RecordFormat = {
+      formatVersion: 1,
+      moves: [
+        {
+          moveNumber: 1,
+          color: 'BLACK',
+          row: null,
+          col: null,
+          isPass: false,
+        },
+      ],
+    }
+    const result = validateRecordFormat(record)
+    expect(result.success).toBe(false)
+    if (!result.success) {
+      expect(result.error).toContain('row')
+    }
+  })
+
+  it('should reject pass move with non-null row/col', () => {
+    const record: RecordFormat = {
+      formatVersion: 1,
+      moves: [
+        {
+          moveNumber: 1,
+          color: 'BLACK',
+          row: 2,
+          col: 3,
+          isPass: true,
+        },
+      ],
+    }
+    const result = validateRecordFormat(record)
+    expect(result.success).toBe(false)
+    if (!result.success) {
+      expect(result.error).toContain('isPass')
+    }
+  })
+
+  it('should reject row/col out of range', () => {
+    const record = {
+      formatVersion: 1,
+      moves: [
+        {
+          moveNumber: 1,
+          color: 'BLACK',
+          row: 8,
+          col: 3,
+          isPass: false,
+        },
+      ],
+    } as unknown as RecordFormat
+    const result = validateRecordFormat(record)
+    expect(result.success).toBe(false)
+    if (!result.success) {
+      expect(result.error).toContain('row')
+    }
+  })
+})
+
+describe('serializeRecordFormat', () => {
+  it('should serialize valid record format to JSON string', () => {
+    const record: RecordFormat = {
+      formatVersion: 1,
+      moves: [
+        {
+          moveNumber: 1,
+          color: 'BLACK',
+          row: 2,
+          col: 3,
+          isPass: false,
+        },
+      ],
+    }
+    const json = serializeRecordFormat(record)
+    expect(json).toBeTruthy()
+    const parsed = JSON.parse(json)
+    expect(parsed.formatVersion).toBe(1)
+    expect(parsed.moves).toHaveLength(1)
+  })
+})
diff --git a/src/storage/recordFormat.ts b/src/storage/recordFormat.ts
new file mode 100644
index 0000000..c1dc7bf
--- /dev/null
+++ b/src/storage/recordFormat.ts
@@ -0,0 +1,170 @@
+/**
+ * Record Format (moves-only / formatVersion=1)
+ *
+ * Purpose: export/import/restore "current game" without managing a library.
+ * Encoding: UTF-8 JSON text.
+ * Versioning: formatVersion MUST be present for forward compatibility.
+ */
+
+import type { Move } from '../domain/types'
+
+/**
+ * Record Format schema (moves-only)
+ */
+export interface RecordFormat {
+  readonly formatVersion: 1
+  readonly moves: readonly Move[]
+}
+
+/**
+ * Validation result
+ */
+export type ValidationResult =
+  | { readonly success: true }
+  | { readonly success: false; readonly error: string }
+
+/**
+ * Validate Record Format according to schema rules
+ */
+export function validateRecordFormat(record: unknown): ValidationResult {
+  // Type guard: check if it's an object
+  if (typeof record !== 'object' || record === null) {
+    return { success: false, error: 'Record must be an object' }
+  }
+
+  const obj = record as Record<string, unknown>
+
+  // Check formatVersion
+  if (!('formatVersion' in obj)) {
+    return { success: false, error: 'formatVersion is required' }
+  }
+  if (obj.formatVersion !== 1) {
+    return {
+      success: false,
+      error: `formatVersion must be 1, got ${obj.formatVersion}`,
+    }
+  }
+
+  // Check moves
+  if (!('moves' in obj)) {
+    return { success: false, error: 'moves is required' }
+  }
+  if (!Array.isArray(obj.moves)) {
+    return { success: false, error: 'moves must be an array' }
+  }
+
+  const moves = obj.moves as unknown[]
+
+  // Validate each move
+  for (let i = 0; i < moves.length; i++) {
+    const move = moves[i]
+    if (typeof move !== 'object' || move === null) {
+      return {
+        success: false,
+        error: `moves[${i}] must be an object`,
+      }
+    }
+
+    const moveObj = move as Record<string, unknown>
+
+    // Check moveNumber
+    if (typeof moveObj.moveNumber !== 'number') {
+      return {
+        success: false,
+        error: `moves[${i}].moveNumber must be a number`,
+      }
+    }
+
+    // Check color
+    if (moveObj.color !== 'BLACK' && moveObj.color !== 'WHITE') {
+      return {
+        success: false,
+        error: `moves[${i}].color must be 'BLACK' or 'WHITE'`,
+      }
+    }
+
+    // Check isPass
+    if (typeof moveObj.isPass !== 'boolean') {
+      return {
+        success: false,
+        error: `moves[${i}].isPass must be a boolean`,
+      }
+    }
+
+    // Check row/col based on isPass
+    if (moveObj.isPass) {
+      if (moveObj.row !== null || moveObj.col !== null) {
+        return {
+          success: false,
+          error: `moves[${i}]: when isPass=true, row and col must be null`,
+        }
+      }
+    } else {
+      if (typeof moveObj.row !== 'number' || typeof moveObj.col !== 'number') {
+        return {
+          success: false,
+          error: `moves[${i}]: when isPass=false, row and col must be numbers`,
+        }
+      }
+      if (
+        moveObj.row < 0 ||
+        moveObj.row > 7 ||
+        moveObj.col < 0 ||
+        moveObj.col > 7
+      ) {
+        return {
+          success: false,
+          error: `moves[${i}]: row and col must be in range 0..7`,
+        }
+      }
+    }
+  }
+
+  // Check moveNumber ordering and gaps
+  if (moves.length > 0) {
+    const moveNumbers = moves.map(
+      (m) => (m as Record<string, unknown>).moveNumber as number
+    )
+    for (let i = 0; i < moveNumbers.length; i++) {
+      if (moveNumbers[i] !== i + 1) {
+        return {
+          success: false,
+          error: `moves must be sorted by moveNumber ascending with no gaps (expected ${i + 1}, got ${moveNumbers[i]})`,
+        }
+      }
+    }
+  }
+
+  return { success: true }
+}
+
+/**
+ * Serialize Record Format to JSON string
+ */
+export function serializeRecordFormat(record: RecordFormat): string {
+  return JSON.stringify(record, null, 2)
+}
+
+/**
+ * Parse JSON string to Record Format (with validation)
+ */
+export function parseRecordFormat(
+  json: string
+): ValidationResult & { record?: RecordFormat } {
+  try {
+    const parsed = JSON.parse(json) as unknown
+    const validation = validateRecordFormat(parsed)
+    if (validation.success) {
+      return {
+        success: true,
+        record: parsed as RecordFormat,
+      }
+    }
+    return validation
+  } catch (error) {
+    return {
+      success: false,
+      error: `JSON parse error: ${error instanceof Error ? error.message : String(error)}`,
+    }
+  }
+}
